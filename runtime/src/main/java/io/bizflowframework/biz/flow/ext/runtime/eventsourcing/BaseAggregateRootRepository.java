package io.bizflowframework.biz.flow.ext.runtime.eventsourcing;

import io.bizflowframework.biz.flow.ext.runtime.AggregateId;
import io.bizflowframework.biz.flow.ext.runtime.AggregateVersion;
import io.bizflowframework.biz.flow.ext.runtime.eventsourcing.creational.AggregateRootInstanceCreator;
import io.bizflowframework.biz.flow.ext.runtime.eventsourcing.event.AggregateRootEventPayload;
import io.bizflowframework.biz.flow.ext.runtime.eventsourcing.event.EventRepository;
import io.bizflowframework.biz.flow.ext.runtime.eventsourcing.event.EventType;
import jakarta.enterprise.inject.Instance;
import jakarta.transaction.Transactional;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public abstract class BaseAggregateRootRepository<ID extends AggregateId, T extends AggregateRoot<ID, T>> implements AggregateRootRepository<ID, T> {
    private final EventRepository<ID, T> eventRepository;
    private final AggregateRootInstanceCreator aggregateRootInstanceCreator;
    private final Instance<BaseOnSavedEvent<ID, T, ? extends AggregateRootEventPayload<T>>> onSavedEvent;

    public BaseAggregateRootRepository(final EventRepository<ID, T> eventRepository,
                                       final AggregateRootInstanceCreator aggregateRootInstanceCreator,
                                       final Instance<BaseOnSavedEvent<ID, T, ? extends AggregateRootEventPayload<T>>> onSavedEvent) {
        this.eventRepository = Objects.requireNonNull(eventRepository);
        this.aggregateRootInstanceCreator = Objects.requireNonNull(aggregateRootInstanceCreator);
        this.onSavedEvent = Objects.requireNonNull(onSavedEvent);
    }

    @Override
    @Transactional
    public T save(final T aggregateRoot) throws EventStoreException {
        Objects.requireNonNull(aggregateRoot);
        while (aggregateRoot.hasDomainEvent()) {
            final AggregateRootDomainEvent<ID, T, ? extends AggregateRootEventPayload<T>> domainEventToSave = aggregateRoot.consumeDomainEvent();
            eventRepository.save(domainEventToSave);
            getOnSaveEventInstances(aggregateRoot.aggregateRootIdentifier.aggregateType(), domainEventToSave.eventType())
                    .forEach(bean -> bean.execute(
                            domainEventToSave.aggregateRootIdentifier(),
                            domainEventToSave.aggregateVersion(),
                            domainEventToSave.createdAt(),
                            domainEventToSave.payload()
                    ));
        }
        return aggregateRoot;
    }

    private List<BaseOnSavedEvent> getOnSaveEventInstances(final AggregateType aggregateType, final EventType eventType) {
        return onSavedEvent.stream()
                .filter(bean -> aggregateType.equals(bean.aggregateType()))
                .filter(bean -> eventType.equals(bean.eventType()))
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public T load(final ID aggregateId) throws UnknownAggregateRootException, EventStoreException {
        Objects.requireNonNull(aggregateId);
        final T instance = aggregateRootInstanceCreator.createNewInstance(clazz(), aggregateId);
        final List<AggregateRootDomainEvent> aggregateRootEvents = eventRepository.loadOrderByVersionASC(instance.aggregateRootIdentifier());
        if (aggregateRootEvents.isEmpty()) {
            throw new UnknownAggregateRootException(instance.aggregateRootIdentifier());
        }
        instance.loadFromHistory(aggregateRootEvents);
        return instance;
    }

    @Override
    @Transactional
    public T load(final ID aggregateId, final AggregateVersion aggregateVersion)
            throws UnknownAggregateRootException, UnknownAggregateRootAtVersionException, EventStoreException {
        Objects.requireNonNull(aggregateId);
        Objects.requireNonNull(aggregateVersion);
        final T instance = aggregateRootInstanceCreator.createNewInstance(clazz(), aggregateId);
        final List<AggregateRootDomainEvent> aggregateRootEvents = eventRepository.loadHavingMaxVersionOrderByVersionASC(instance.aggregateRootIdentifier(), aggregateVersion);
        if (aggregateRootEvents.isEmpty()) {
            throw new UnknownAggregateRootException(instance.aggregateRootIdentifier());
        }
        instance.loadFromHistory(aggregateRootEvents);
        if (!instance.aggregateVersion().equals(aggregateVersion)) {
            throw new UnknownAggregateRootAtVersionException(instance.aggregateRootIdentifier(), aggregateVersion);
        }
        return instance;
    }

    protected Class<T> clazz() {
        throw new RuntimeException("Do not implement. Will be generated by extension :)");
    }
}
